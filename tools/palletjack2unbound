#!/usr/bin/env ruby
#
# Write DNS resolver stub declarations from a Palletjack warehouse
#
# Data model assumptions:
#
#   service:
#     unbound:
#       server:
#         - interface: 0.0.0.0
#         - access-control: 192.0.2.0/24 allow
#         - ...
#
# Other configuration categories than +system+ are not supported.

require 'palletjack'
require 'optparse'
require 'ip'

$options = {}

# Ignore any Error::EEXIST raised by block argument

def exists_ok(&code)
  code.call()
rescue Errno::EEXIST
  nil
end

# Write a stub-zone declaration to a file in conf.d/
# If the +transparent+ option is true, also write
# a local-zone ... transparent, declaration e.g. to
# override the builtin RFC1918 blocking in unbound.

def stub_zone(zone, stub_addrs, options = {})
  return if stub_addrs.empty?

  File.open("#{$options[:conf_dir]}/#{zone}.conf",
            File::CREAT | File::TRUNC | File::WRONLY, 0644) do |stubfile|
    stubfile <<
      "################################################################
# Automatically generated by palletjack2unbound from
# #{$options[:warehouse]}
################################################################

stub-zone:
  name: #{zone}\n"

    stub_addrs.each do |addr|
      stubfile << "  stub-addr: #{addr}\n"
    end

    if options[:transparent] then
      stubfile << "\nserver:\n  local-zone: \"#{zone}\" transparent\n"
    end
  end
end

# Check if +ip+ belongs to some RFC1918 network

def rfc1918?(ip)
  rfc1918_nets = [IP.new('10.0.0.0/8'),
                  IP.new('172.16.0.0/12'),
                  IP.new('192.168.0.0/16')]
  rfc1918_nets.any? {|net| ip.is_in?(net)}
end

# Generate unbound service configuration

def unbound_config(file_name, service_config)
  File.open("#{$options[:local_dir]}/#{file_name}.conf",
            File::CREAT | File::TRUNC | File::WRONLY, 0644) do |configfile|
    configfile <<
      "################################################################
# Automatically generated by palletjack2unbound from
# #{$options[:warehouse]}
################################################################

"
    service_config["service.unbound.server"].each do |config|
      config.each do |key, value|
        configfile << "#{key}: #{value}\n"
      end
    end
  end
end

opts = OptionParser.new
opts.banner = "Usage: #{$PROGRAM_NAME} -w <warehouse> -s <service> -o <output directory>

Write DNS resolver stub declarations from a Palletjack warehouse
into Salt state configuration for unbound.

E.g.
  palletjack2unbound -w /etc/salt/respository/warehouse \\
    -o /etc/salt/repository/state/unbound/files

"

opts.on('-w DIR', '--warehouse DIR', 'warehouse directory', String) {|dir|
  $options[:warehouse] = dir }
opts.on('-o DIR', '--output DIR', 'output directory', String) {|dir|
  $options[:output] = dir
  $options[:conf_dir] = "#{dir}/conf.d"
  $options[:local_dir] = "#{dir}/local.d"
}
opts.on('-s SERVICE', '--service SERVICE',
        'service name for global configuration', String) {|service|
  $options[:service] = service }

opts.parse!

if not $options[:warehouse] or
    not $options[:output] or
    not $options[:service] or
    not File.directory?($options[:output])
  puts opts.to_s
  exit 1
end

exists_ok { Dir.mkdir($options[:conf_dir]) }
exists_ok { Dir.mkdir($options[:local_dir]) }

jack = PalletJack.new($options[:warehouse])

jack['domain'].each do |domain|
  zone = domain['net.dns.domain']
  stub_addrs = []

  domain['net.dns.ns'].each do |ns|
    jack['ipv4_interface', with_all:{'net.dns.fqdn' => ns}].each do |ipv4|
      stub_addrs << ipv4['net.ipv4.address']
    end
  end

  stub_zone(zone, stub_addrs)

  next unless domain['net.ipv4.cidr']

  # Assume all delegations happen on octet boundaries for now.
  # TODO: RFC 2317 classless in-addr.arpa delegation

  ip_net = IP.new(domain['net.ipv4.cidr'])
  reverse_zone = ip_net.to_arpa
  prefix_octets, _ = domain['net.ipv4.prefixlen'].to_i.divmod(8)
  reverse_zone = ip_net.to_arpa.split('.')[-(2 + prefix_octets) .. 5].join('.')

  # Make the same assumption that palletjack2knot does;
  # reverse delegations are made to the same nameserver
  # as forward delegations.

  stub_zone(reverse_zone, stub_addrs,
            transparent: rfc1918?(ip_net))
end

jack['service', name: $options[:service]].each do |service_config|
  unbound_config($options[:service], service_config)
end
