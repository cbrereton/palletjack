#!/usr/bin/env ruby

# Write DNS resolver stub declarations from a Palletjack warehouse

require 'palletjack'
require 'optparse'
require 'dns/zone'
require 'ip'

$options = {}

# Ignore any Error::EEXIST raised by block argument

def exists_ok(&code)
  code.call()
rescue Errno::EEXIST
  nil
end

def stub_zone(zone, *stub_addrs)
  head = "################################################################
# Automatically generated by palletjack2unbound from 
# #{$options[:warehouse]}
################################################################

stub-zone:
  name: #{zone}\n"

  stub_addrs.inject(head) do |result, addr|
    result << "  stub-addr: #{addr}\n"
  end
end

opts = OptionParser.new
opts.banner = "Usage: #{$PROGRAM_NAME} -w <warehouse> -d <output directory>

Write DNS resolver stub declarations from a Palletjack warehouse
into Salt state configuration for unbound.

E.g.
  palletjack2unbound -w /etc/salt/respository/warehouse \\
    -o /etc/salt/repository/state/unbound/files

"
opts.on("-w DIR", "--warehouse DIR", "warehouse directory", String) {|dir|
  $options[:warehouse] = dir }
opts.on("-o DIR", "--output DIR", "output directory", String) {|dir|
  $options[:output] = dir
  $options[:conf_dir] = "#{dir}/conf.d"
}
opts.parse!

if not $options[:warehouse] or
    not $options[:output] or
    not File.directory?($options[:output])
  puts opts.to_s
  exit 1
end

exists_ok { Dir.mkdir($options[:conf_dir]) }

jack = PalletJack.new($options[:warehouse])

jack["domain"].each do |domain|
  zone = "#{domain['net.dns.domain']}"

  stub_addrs = []
  domain['net.dns.ns'].each do |ns|
    jack["ipv4_interface", with_all:{"net.dns.fqdn" => ns}].each do |ipv4|
      stub_addrs << ipv4["net.ipv4.address"]
    end
  end

  File.open("#{$options[:conf_dir]}/#{domain['net.dns.domain']}.conf",
            File::CREAT | File::TRUNC | File::WRONLY, 0644) do |stubfile|
    stubfile << stub_zone(zone, *stub_addrs)
  end unless stub_addrs.empty?
end
