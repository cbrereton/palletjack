#!/usr/bin/env ruby

# Write DNS server zone file from a Palletjack warehouse
#
# Data model assumptions:
# - Each domain corresponds uniquely to one IPv4 network
#
# The YAML key "net.dns.alias" is used to create CNAME aliases for
# each interface. This means that if a "system" object specifies
# "net.dns.alias", each of its interfaces will get that alias in its
# own domain. Aliases explicitly specified on a single interface will
# override this.

require 'palletjack'
require 'optparse'
require 'dns/zone'
require 'ip'

options = {}

def exists_ok(&code)
  code.call()
rescue Errno::EEXIST
  nil
end

def zone_config(zone)
  "
#{zone} {
  file \"zones/#{zone}.zone\";
}
"
end

opts = OptionParser.new
opts.banner = "Usage: #{$PROGRAM_NAME} -w <warehouse> -d <output directory>

Write DNS server zone files from a Palletjack warehouse

"
opts.on('-w DIR', '--warehouse DIR', 'warehouse directory', String) {|dir| options[:warehouse] = dir }
opts.on('-o DIR', '--output DIR', 'output directory', String) {|dir|
  options[:output] = dir
  options[:zone_dir] = "#{dir}/zones"
}
opts.parse!

if not options[:warehouse] or
    not options[:output] or
    not File.directory?(options[:output])
  puts opts.to_s
  exit 1
end

exists_ok { Dir.mkdir(options[:zone_dir]) }

# Use Unix timestamp as serial number, and get it once so all zones get the same one
serial = Time.now.utc.to_i

jack = PalletJack.new(options[:warehouse])

File.open("#{options[:output]}/zones.conf",
          File::CREAT | File::TRUNC | File::WRONLY, 0644) do |config_file|

  config_file <<
    "################
## Automatically generated by palletjack2knot from #{options[:warehouse]}
################
"

  jack['domain'].each do |domain|
    absolute_domain_name = "#{domain['net.dns.domain']}."

    zone = DNS::Zone.new

    zone.origin = absolute_domain_name
    zone.ttl = domain['net.dns.ttl']

    zone.soa.serial = serial
    zone.soa.label = absolute_domain_name
    zone.soa.nameserver = domain['net.dns.soa-ns']
    zone.soa.email = "#{domain['net.dns.soa-contact']}.".sub('@', '.')

    if domain['net.dns.mx']
      domain['net.dns.mx'].each do |server|
        mx = DNS::Zone::RR::MX.new
        mx.label = absolute_domain_name
        mx.priority = server['priority']
        mx.exchange = server['server']
        zone.records << mx
      end
    end

    domain['net.dns.ns'].each do |address|
      ns = DNS::Zone::RR::NS.new
      ns.label = absolute_domain_name
      ns.nameserver = address
      zone.records << ns
    end

    if domain['net.dns.cname']
      domain['net.dns.cname'].each do |name, target|
        cname = DNS::Zone::RR::CNAME.new
        cname.label = name
        cname.domainname = target
        zone.records << cname
      end
    end

    if domain['net.dns.srv']
      domain['net.dns.srv'].each do |service|
        srv = DNS::Zone::RR::SRV.new
        srv.label = "_#{service['service']}._#{service['protocol']}"
        srv.target = service['target']
        srv.port = service['port']
        service['priority'] ||= 0
        srv.priority = service['priority']
        service['weight'] ||= 0
        srv.weight = service['weight']
        zone.records << srv
      end
    end

    jack['ipv4_interface',
         with_all:{'net.dns.domain' =>
           domain['net.dns.domain']}].each do |interface|
      a = DNS::Zone::RR::A.new
      a.label = interface['net.dns.name']
      a.address = interface['net.ipv4.address']
      zone.records << a

      if interface['net.dns.alias']
        interface['net.dns.alias'].each do |label|
          cname = DNS::Zone::RR::CNAME.new
          cname.label = label
          cname.domainname = interface['net.dns.name']
          zone.records << cname
        end
      end
    end

    File.open("#{options[:zone_dir]}/#{domain['net.dns.domain']}.zone", File::CREAT | File::TRUNC | File::WRONLY, 0644) do |zonefile|
      zonefile <<
        ";;;;;;;;;;
; Automatically generated by palletjack2knot from #{options[:warehouse]}
;;;;;;;;;;

"
      zonefile << zone.dump_pretty
    end

    config_file << zone_config(domain['net.dns.domain'])

    next unless domain['net.ipv4.cidr']

    # Assume all delegations happen on octet boundaries for now.
    # TODO: RFC 2317 classless in-addr.arpa delegation

    reverse_zone = DNS::Zone.new

    ip_net = IP.new(domain['net.ipv4.cidr'])
    absolute_reverse_zone_name = ip_net.to_arpa

    prefix_octets, _ = domain['net.ipv4.prefixlen'].to_i.divmod(8)
    reverse_zone.origin = absolute_reverse_zone_name.split('.')[-(2 + prefix_octets) .. 5].join('.')

    reverse_zone.ttl = domain['net.dns.ttl']

    reverse_zone.soa.serial = serial
    reverse_zone.soa.label = "#{reverse_zone.origin}."
    reverse_zone.soa.nameserver = domain['net.dns.soa-ns']
    reverse_zone.soa.email = "#{domain['net.dns.soa-contact']}.".sub('@', '.')

    domain['net.dns.ns'].each do |address|
      ns = DNS::Zone::RR::NS.new
      ns.label = "#{reverse_zone.origin}."
      ns.nameserver = address
      reverse_zone.records << ns
    end

    jack['ipv4_interface',
         with_all:{'net.dns.domain' =>
           domain['net.dns.domain']}].each do |interface|
      ptr = DNS::Zone::RR::PTR.new
      ptr.label = IP.new(interface['net.ipv4.address']).to_arpa
      ptr.name = "#{interface['net.dns.fqdn']}."
      reverse_zone.records << ptr
    end

    File.open("#{options[:zone_dir]}/#{reverse_zone.origin}.zone", File::CREAT | File::TRUNC | File::WRONLY, 0644) do |zonefile|
      zonefile <<
        ";;;;;;;;;;
; Automatically generated by palletjack2knot from #{options[:warehouse]}
;;;;;;;;;;

"
      zonefile << reverse_zone.dump_pretty
    end

    config_file << zone_config(reverse_zone.origin)
  end
end
