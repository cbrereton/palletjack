#!/usr/bin/env ruby

# Write YAML files containing Salt external pillar data for all
# systems, one file per system.
#
# Intended to be run from a Git post-update hook or similar, writing
# YAML files which will be read by a Salt palletjack_yaml_file
# external pillar (which you will have to install manually), since
# running the entire Pallet Jack infrastructure once per minion for
# every pillar refresh is a bit excessive.
#
# Example Salt master configuration:
#
#   ext_pillar:
#     - palletjack_yaml_file: /var/cache/palletjack/{environment}/{minion}.yaml
#
# Data model assumptions:
# - Salt minion ID is FQDN

require 'palletjack'
require 'optparse'
require 'yaml'

options = {}

opts = OptionParser.new
opts.banner = "Usage: #{$PROGRAM_NAME} -w <warehouse> -d <output directory>

Write Salt pillar data from a Palletjack warehouse, one YAML file per system

"
opts.on('-w DIR', '--warehouse DIR', 'warehouse directory', String) {|dir| options[:warehouse] = dir }
opts.on('-o DIR', '--output DIR', 'output directory', String) {|dir| options[:output] = dir }
opts.parse!

if not options[:warehouse] or
    not options[:output] or
    not File.directory?(options[:output])
  puts opts.to_s
  exit 1
end

jack = PalletJack.new(options[:warehouse])

jack['system'].each do |system|
  yaml_output = { 'ipv4_interfaces' => {} }
  system.children.each do |interface|
    next unless interface.kind == 'ipv4_interface'
    yaml_output['ipv4_interfaces'][interface['net.layer2.name']] = {
      interface['net.ipv4.address'] =>
      interface.filter('net.ipv4', 'net.layer2').to_hash
    }
  end

  yaml_output['system'] = system['system']

  yaml_output['service'] = { 'syslog' => system['net.service.syslog'] }

  File.open("#{options[:output]}/#{system['net.dns.fqdn']}.yaml", File::CREAT | File::TRUNC | File::WRONLY, 0644) do |yamlfile|
    yamlfile << { 'palletjack' => yaml_output }.to_yaml
  end
end
